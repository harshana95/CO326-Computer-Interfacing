//************************************************************************************
//**  
//**  Source name:   D:\Campus\sem 6\CO326  Computer Systems Engineering Industrial Networks\labs\Flowcode1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4550
//**  
//**  Generated by:  Flowcode v7.1.1.0
//**  Date:          Sunday, January 13, 2019 11:13:13
//**  Users:         1
//**  Registered to: 
//**  Licence key:   ??????
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 19660800

#define FCP_NULL Unconnected_Port



#include <xc.h>
#include <math.h>

__PROG_CONFIG(0x1, 0xFEE4);
__PROG_CONFIG(0x2, 0xFEFF);
__PROG_CONFIG(0x3, 0xFFFF);
__PROG_CONFIG(0x4, 0xFF9B);
__PROG_CONFIG(0x5, 0xFFFF);
__PROG_CONFIG(0x6, 0xFFFF);
__PROG_CONFIG(0x7, 0xFFFF);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_STRING_DATA 20
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_MODE = (0x1);
MX_GLOBAL MX_UINT8 FCV_BYTE_DATA = (0x8);
MX_GLOBAL MX_CHAR FCV_STRING_DATA[FCVsz_STRING_DATA];


/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d92_led_base1__TurnOn();
void FCD_03d92_led_base1__TurnOff();

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d91_led_base1__TurnOn();
void FCD_03d91_led_base1__TurnOff();

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_i2c1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_I2C_SDA_PORT_1 portc
#define MX_I2C_REF1 
#define MX_I2C_1 
#define MX_I2C_BMODE_1 (0)
#define MX_I2C_SDA_TRIS_1 trisc
#define MX_I2C_SCL_PIN_1 (3)
#define MX_I2C_SCL_PORT_1 portc
#define MX_I2C_STOPDEL_1 (1)
#define MX_I2C_SDA_PIN_1 (4)
#define MX_I2C_SCL_TRIS_1 trisc
#define MX_I2C_BAUD_1 (100000)
#define MX_I2C_CHANNEL_1 (0)


/*=----------------------------------------------------------------------=*\
   Use :cal_i2c1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_MI2C
MX_GLOBAL MX_UINT32 FCV_07da1_cal_i2c1__CONSOLE;

void FC_CAL_I2C_Slave_Uninit_1();
void FCD_07da1_cal_i2c1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR);
void FC_CAL_I2C_Master_Stop_1();
void FC_CAL_I2C_Slave_Init_1(MX_UINT8 FCL_ADDRESS, MX_UINT8 FCL_MASK);
void FC_CAL_I2C_Master_Uninit_1();
MX_UINT8 FC_CAL_I2C_Slave_Status_1();
MX_UINT8 FC_CAL_I2C_Slave_TxByte_1(MX_UINT8 FCL_DATA);
MX_UINT8 FC_CAL_I2C_Slave_RxByte_1(MX_UINT8 FCL_LAST);
void FC_CAL_I2C_Master_Init_1();
void FC_CAL_I2C_Master_Start_1();
MX_UINT8 FC_CAL_I2C_Master_TxByte_1(MX_UINT8 FCL_DATA);
void FC_CAL_I2C_Master_Restart_1();
MX_UINT8 FC_CAL_I2C_Master_RxByte_1(MX_UINT8 FCL_LAST);

/*========================================================================*\
   Use :ctrl_lcd
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_04071_LCD__Clear();
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE);
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION);
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT);
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE);
void FCD_04071_LCD__Start();

/*========================================================================*\
   Use :lcd_I2C1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_0c591_lcd_I2C1__Clear();
void FCD_0c591_lcd_I2C1__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT);
void FCD_0c591_lcd_I2C1__PrintAscii(MX_UINT8 FCL_CHARACTER);
void FCD_0c591_lcd_I2C1__PrintNumber(MX_SINT16 FCL_NUMBER);
void FCD_0c591_lcd_I2C1__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7);
void FCD_0c591_lcd_I2C1__BacklightControl(MX_UINT8 FCL_STATE);
void FCD_0c591_lcd_I2C1__ClearLine(MX_UINT8 FCL_LINE);
void FCD_0c591_lcd_I2C1__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y);
void FCD_0c591_lcd_I2C1__Command(MX_UINT8 FCL_INSTRUCTION);
#define FCD_0c591_lcd_I2C1__PrintFormattedNumber FCD_04071_LCD__PrintFormattedNumber
void FCD_0c591_lcd_I2C1__EnablePulse(MX_UINT8 FCL_DATA);
void FCD_0c591_lcd_I2C1__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION);
void FCD_0c591_lcd_I2C1__RawSend(MX_UINT8 FCL_DATA, MX_UINT8 FCL_MASK);
void FCD_0c591_lcd_I2C1__Start();

/*========================================================================*\
   Use :dash_IO_flasher1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :USB_Serial1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define dev_name 40,3,'F',0,'l',0,'o',0,'w',0,'c',0,'o',0,'d',0,'e',0,' ',0,'U',0,'S',0,'B',0,' ',0,'S',0,'e',0,'r',0,'i',0,'a',0,'l',0
#define dev_name_count 40
#define dev_name_DS 'F','l','o','w','c','o','d','e',' ','U','S','B',' ','S','e','r','i','a','l'
#define dev_name_count_DS 19
#define MX_USB_TYPE1
#define timeout 10
#define RX_BUF_SZ (64)
#define MX_VID 4799
#define enumeration_tout 0
#define TX_BUF_SZ (64)
#define major_version 1
#define MX_PID 61456
#define dev_manufacturer 46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0
#define dev_manufacturer_count 46
#define dev_manufacturer_DS 'M','a','t','r','i','x',' ','M','u','l','t','i','m','e','d','i','a',' ','L','t','d','.'
#define dev_manufacturer_count_DS 22
#define minor_version 0


/*=----------------------------------------------------------------------=*\
   Use :USB_Serial1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_VERSION ((major_version << 8) | minor_version)

#ifdef MX_CAL_PIC							//8-bit PIC specific

    #ifdef MX_USB_TYPE1                     //ECIO / MIAC / 18F4455
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x500
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x540
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x580
    #endif

    #ifdef MX_USB_TYPE3                     //18F14K50
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x240
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x280
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x2C0
    #endif

    #ifdef MX_USB_TYPE5                     //16F1455
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x0A0
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x120
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x1A0
    #endif

    #ifdef MX_USB_TYPE6                     //18F45K50
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x500
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x540
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x580
    #endif

	#ifdef MX_USB_TYPE0
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"../../../CAL/PIC/USB/usb_serial_config.h"

    #include USB_CONFIG

	// USB library includes
	#include "../../../CAL/PIC/USB/usb.h"
	#include "../../../CAL/PIC/USB/usb_device.h"
	#include "../../../CAL/PIC/USB/usb_device_cdc.h"
	//#include "../../../CAL/PIC/USB/system.h"

    #include "../../../CAL/PIC/USB/usb_device.c"
    #include "../../../CAL/PIC/USB/usb_device_cdc.c"
    #include "../../../CAL/PIC/USB/usb_hal_16bit.c"
	//#include "../../../CAL/PIC/USB/system.c"
	
	// Device name and manufacturer
    const struct{uint8_t bLength;uint8_t bDscType;uint16_t string[dev_manufacturer_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};
    const struct{uint8_t bLength;uint8_t bDscType;uint16_t string[dev_name_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_name_DS}};

    #include "../../../CAL/PIC/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC/USB/usb_serial_handler.c"

#endif

#ifdef MX_CAL_PIC16					//16-bit PIC specific

	#ifndef MX_USB_TYPE1
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"usb_serial_config.h"

	// USB library includes
	#include "../../../CAL/PIC16BIT/USB/usb_serial_config.h"
	#include "../../../CAL/PIC16BIT/USB/usb.h"
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.h"
	#include "../../../CAL/PIC16BIT/USB/GenericTypeDefs.h"
	#include "../../../CAL/PIC16BIT/USB/Compiler.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.c"
	#include "../../../CAL/PIC16BIT/USB/usb_ch9.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.c"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.c"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.c"
    #endif
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.c"
	#include "../../../CAL/PIC16BIT/USB/usb_common.h"
	#include "../../../CAL/PIC16BIT/USB/usb_hal.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.h"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.h"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.h"
    #endif
	
	// Device name and manufacturer
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_name_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_name_DS}};
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_manufacturer_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};

	#include "../../../CAL/PIC16BIT/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC16BIT/USB/usb_cdc_handler.c"

#endif


#ifdef MX_CAL_AVR					//AVR specific

#include "config.h"
#include "lib_mcu/usb/usb_drv.h"
#include "modules\usb\device_chap9\usb_standard_request.h"
#include "usb_specific_request.h"
#include "uart_usb_lib.h"

extern U8    rx_counter;
extern U8    tx_counter;

S_line_coding line_coding;
S_line_status line_status;      // for detection of serial state input lines
S_serial_state serial_state;    // for serial state output lines

#endif

MX_UINT8 FCD_056e1_USB_Serial1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
void FCD_056e1_USB_Serial1__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH);
MX_UINT8 FCD_056e1_USB_Serial1__SendByte(MX_UINT8 FCL_DATA);
MX_UINT16 FCD_056e1_USB_Serial1__ReadByte(MX_UINT8 FCL_TIMEOUT_MS);
MX_UINT8 FCD_056e1_USB_Serial1__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\includes.c"


/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOn()
{

	FCP_SET(B, E, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOff()
{

	FCP_SET(B, E, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOn()
{

	FCP_SET(B, A, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOff()
{

	FCP_SET(B, A, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_i2c1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Send text to the console
       :
       :Parameters for macro Prv_TextConsole:
       :  str[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_07da1_cal_i2c1__Prv_TextConsole(MX_CHAR *FCL_STR, MX_UINT16 FCLsz_STR)
{


}


/*========================================================================*\
   Use :ctrl_lcd
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :LCD
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Clears the entire contents of the display.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Clear()
{




	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Breaks down a string of text and sends it to the LCD via the private RawSend(byte, mask) macro
       :
       :Parameters for macro PrintString:
       :  Text[20] : Enter the text or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;



	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		FCD_04071_LCD__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		FCL_IDX = FCL_IDX + 1;


	}


}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : Holds an ascii value.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_04071_LCD__RawSend(FCL_CHARACTER, 0x10);



}

/*=----------------------------------------------------------------------=*\
   Use :Based on v5 macro, will allow you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : Enter the number or variable to print to the LCD
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : Values 0 to 7
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_04071_LCD__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(FCL_D0, 0x10);

	FCD_04071_LCD__RawSend(FCL_D1, 0x10);

	FCD_04071_LCD__RawSend(FCL_D2, 0x10);

	FCD_04071_LCD__RawSend(FCL_D3, 0x10);

	FCD_04071_LCD__RawSend(FCL_D4, 0x10);

	FCD_04071_LCD__RawSend(FCL_D5, 0x10);

	FCD_04071_LCD__RawSend(FCL_D6, 0x10);

	FCD_04071_LCD__RawSend(FCL_D7, 0x10);

	FCD_04071_LCD__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Clears a single line on the display and then moves the cursor to the start of the line to allow you to start populating the line with data.
       :
       :Parameters for macro ClearLine:
       :  Line : The line to clear, zero being the first (top) line of the display
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 4)
	{

		FCD_04071_LCD__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 20)
		{


			FCD_04071_LCD__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_04071_LCD__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : Set the cursor position in the X plane, 0 is the left most cell
       :  y : Set the cursor position in the Y plane, 0 is the top most cell
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{



	#if (0) // 4 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 4 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 4 == 4

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			if (FCL_Y == 1)
			{

				FCL_Y = 0xC0;

			} else {

				#if (0) // 20 == 16

				//Code has been optimised out by the pre-processor
				#else

					#if (1) // 20 == 20

						if (FCL_Y == 2)
						{

							FCL_Y = 0x94;

						} else {

							FCL_Y = 0xd4;

						}

					// #else

					//Code has been optimised out by the pre-processor
					#endif

				#endif

			}

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	FCD_04071_LCD__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : Send a defined command to the LCD Screen. See datasheet for supported commands.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_04071_LCD__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Will allow you to print a number up to 32-bits with signed or unsigned formatting.

       :Signed = -2147483648 to 2147483647

       :Unsigned = 0 to 4294967295
       :
       :Parameters for macro PrintFormattedNumber:
       :  Number : Enter the number or variable to print to the LCD
       :  Format : 0=Signed, 1=Unsigned
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__PrintFormattedNumber(MX_UINT32 FCL_NUMBER, MX_BOOL FCL_FORMAT)
{
	//Local variable definitions
	#define FCLsz_S 15
	MX_CHAR FCL_S[FCLsz_S];


	if (FCL_FORMAT == 1)
	{

		FCI_UTOS32(FCL_NUMBER, FCL_S,15);

	} else {

		FCI_ITOS32((MX_SINT32)(FCL_NUMBER), FCL_S,15);

	}

	FCD_04071_LCD__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  Position : Holds the number of positions to shift the display
       :  direction : 0 = left, 1 = right
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD = (0x0);


	FCL_CMD = 0;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;


			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;


			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;


			break;
		}
		// default:

	}

	if (FCL_CMD != 0 && FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_04071_LCD__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : The data byte to send to the LCD
       :  type : A boolean to indicate command type: true to write data, false to write a command
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__RawSend(MX_UINT8 FCL_DATA, MX_BOOL FCL_TYPE)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;


	//Comment:
	//Output upper nibble of the byte

	#if (1) // 0 == 0

		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);

		#if (0)

		//Code has been optimised out by the pre-processor
		// #else

		#endif

		FCL_NIBBLE = (FCL_DATA >> 4);
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	//Comment:
	//Output byte to pins

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	//Comment:
	//Output byte to port

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	if (FCL_TYPE)
	{

		FCP_SET(B, C, 0x10, 0x4, 1);

	// } else {

	}

	FCI_DELAYBYTE_US(100);

	//Comment:
	//Set Enable high, pause then set low

	//to acknowledge the data has been 
	//submitted.

	FCP_SET(B, C, 0x10, 0x4, 1);

	FCI_DELAYBYTE_US(100);

	FCP_SET(B, C, 0x10, 0x4, 0);

	FCI_DELAYBYTE_US(100);

	#if (1) // 0 == 0

		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);

		FCL_NIBBLE = (FCL_DATA & 0xf);
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));
		FCL_NIBBLE = FCL_NIBBLE >> 1;
		FCP_SET(B, C, 0x10, 0x4, (FCL_NIBBLE & 0x01));

		if (FCL_TYPE)
		{

			FCP_SET(B, C, 0x10, 0x4, 1);

		// } else {

		}

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, C, 0x10, 0x4, 1);

		FCI_DELAYBYTE_US(100);

		FCP_SET(B, C, 0x10, 0x4, 0);

		FCI_DELAYBYTE_US(100);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.

       :Automatically clears the display after initialising.
\*=----------------------------------------------------------------------=*/
void FCD_04071_LCD__Start()
{



	#if (1) // 0 == 0

		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);
		FCP_SET(B, C, 0x10, 0x4, 0);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 0 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0)

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	FCI_DELAYBYTE_MS(12);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x33, 0);

	FCI_DELAYBYTE_MS(2);

	#if (0) // 0 > 0

	//Code has been optimised out by the pre-processor
	#else

		FCD_04071_LCD__RawSend(0x32, 0);

		FCI_DELAYBYTE_MS(2);

		FCD_04071_LCD__RawSend(0x2c, 0);

	#endif

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x06, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x0c, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__RawSend(0x02, 0);

	FCI_DELAYBYTE_MS(2);

	FCD_04071_LCD__Clear();

}


/*========================================================================*\
   Use :lcd_I2C1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__Clear()
{

	FCD_0c591_lcd_I2C1__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro PrintString:
       :  Text[20] : MX_CHAR (by-ref)
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__PrintString(MX_CHAR *FCL_TEXT, MX_UINT16 FCLsz_TEXT)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX = (0x0);
	MX_UINT8 FCL_COUNT;


	FCL_COUNT = FCI_GETLENGTH(FCL_TEXT, FCLsz_TEXT);

	while (FCL_IDX < FCL_COUNT)
	{

		FCD_0c591_lcd_I2C1__RawSend(FCL_TEXT[FCL_IDX], 0x10);

		FCL_IDX = FCL_IDX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Takes the ascii value for a character and prints the character
       :
       :Parameters for macro PrintAscii:
       :  character : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__PrintAscii(MX_UINT8 FCL_CHARACTER)
{

	FCD_0c591_lcd_I2C1__RawSend(FCL_CHARACTER, 0x10);

}

/*=----------------------------------------------------------------------=*\
   Use :Allows you to print a number. This is limited to a signed-INT, -32768 to 32767
       :
       :Parameters for macro PrintNumber:
       :  Number : MX_SINT16
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__PrintNumber(MX_SINT16 FCL_NUMBER)
{
	//Local variable definitions
	#define FCLsz_S 10
	MX_CHAR FCL_S[FCLsz_S];


	FCI_TOSTRING(FCL_NUMBER, FCL_S,10);

	FCD_0c591_lcd_I2C1__PrintString(FCL_S, FCLsz_S);

	//Local variable definitions
	#undef FCLsz_S
}

/*=----------------------------------------------------------------------=*\
   Use :Modifies the internal memory of the LCD to allow for up to 8 customised characters to be created and stored in the device memory
       :
       :Parameters for macro RAMWrite:
       :  Index : MX_UINT8
       :  d0 : MX_UINT8
       :  d1 : MX_UINT8
       :  d2 : MX_UINT8
       :  d3 : MX_UINT8
       :  d4 : MX_UINT8
       :  d5 : MX_UINT8
       :  d6 : MX_UINT8
       :  d7 : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__RAMWrite(MX_UINT8 FCL_INDEX, MX_UINT8 FCL_D0, MX_UINT8 FCL_D1, MX_UINT8 FCL_D2, MX_UINT8 FCL_D3, MX_UINT8 FCL_D4, MX_UINT8 FCL_D5, MX_UINT8 FCL_D6, MX_UINT8 FCL_D7)
{

	FCD_0c591_lcd_I2C1__RawSend(64 + (FCL_INDEX << 3), 0);

	FCI_DELAYBYTE_MS(2);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D0, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D1, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D2, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D3, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D4, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D5, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D6, 0x10);

	FCD_0c591_lcd_I2C1__RawSend(FCL_D7, 0x10);

	FCD_0c591_lcd_I2C1__Clear();

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro BacklightControl:
       :  State : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__BacklightControl(MX_UINT8 FCL_STATE)
{

	FC_CAL_I2C_Master_Start_1();

	FC_CAL_I2C_Master_TxByte_1(32 << 1);

	FC_CAL_I2C_Master_TxByte_1(0);

	if (FCL_STATE)
	{

		FC_CAL_I2C_Master_TxByte_1(0x08);

	} else {

		FC_CAL_I2C_Master_TxByte_1(0);

	}

	FC_CAL_I2C_Master_Stop_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro ClearLine:
       :  Line : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__ClearLine(MX_UINT8 FCL_LINE)
{
	//Local variable definitions
	MX_UINT8 FCL_X;


	if (FCL_LINE < 4)
	{

		FCD_0c591_lcd_I2C1__Cursor(0, FCL_LINE);

		FCL_X = 0;

		while (FCL_X < 20)
		{

			FCD_0c591_lcd_I2C1__RawSend(' ', 0x10);

			FCL_X = FCL_X + 1;


		}

		FCD_0c591_lcd_I2C1__Cursor(0, FCL_LINE);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Moves the cursor on the LCD Display
       :
       :Parameters for macro Cursor:
       :  x : MX_UINT8
       :  y : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__Cursor(MX_UINT8 FCL_X, MX_UINT8 FCL_Y)
{

	#if (0) // 4 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (0) // 4 == 2

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	#if (1) // 4 == 4

		if (FCL_Y == 0)
		{

			FCL_Y = 0x80;

		} else {

			if (FCL_Y == 1)
			{

				FCL_Y = 0xC0;

			} else {

				#if (0) // 20 == 16

				//Code has been optimised out by the pre-processor
				#else

					#if (1) // 20 == 20

						if (FCL_Y == 2)
						{

							FCL_Y = 0x94;

						} else {

							FCL_Y = 0xd4;

						}

					// #else

					//Code has been optimised out by the pre-processor
					#endif

				#endif

			}

		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

	FCD_0c591_lcd_I2C1__RawSend(FCL_Y + FCL_X, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Use this method/macro to send a specific command to the LCD. Refer to the Matrix Multimedia EB006 datasheet for a list of supported instructions. For Non-Matrix LCD's refer to the manufacturers datasheet.
       :
       :Parameters for macro Command:
       :  instruction : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__Command(MX_UINT8 FCL_INSTRUCTION)
{

	FCD_0c591_lcd_I2C1__RawSend(FCL_INSTRUCTION, 0);

	FCI_DELAYBYTE_MS(2);

}

/*=----------------------------------------------------------------------=*\
   Use :Parameters for macro EnablePulse:
       :  data : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__EnablePulse(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT8 FCL_HI;
	MX_UINT8 FCL_LO;
	MX_UINT8 FCL_TBYTE;


	//Comment:
	//Swaps upper and lower nibbles, so lower 4 are now cleared vs upper 4.

	FCL_HI = (FCL_DATA & 0x0F) << 4;
	FCL_LO = (FCL_DATA & 0xF0) >> 4;
	FCL_TBYTE = (FCL_HI | FCL_LO);

	FC_CAL_I2C_Master_Start_1();

	FC_CAL_I2C_Master_TxByte_1(32 << 1);

	FC_CAL_I2C_Master_TxByte_1(FCL_TBYTE | 0x0C);

	FC_CAL_I2C_Master_Stop_1();

	FCI_DELAYBYTE_US(100);

	FC_CAL_I2C_Master_Start_1();

	FC_CAL_I2C_Master_TxByte_1(32 << 1);

	FC_CAL_I2C_Master_TxByte_1(FCL_TBYTE | 0x08);

	FC_CAL_I2C_Master_Stop_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Scrolls the display left or right by a number of given positions.
       :
       :Parameters for macro ScrollDisplay:
       :  position : MX_UINT8
       :  direction : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__ScrollDisplay(MX_UINT8 FCL_POSITION, MX_UINT8 FCL_DIRECTION)
{
	//Local variable definitions
	MX_UINT8 FCL_CMD;


	FCL_CMD = -1;

	switch (FCL_DIRECTION)
	{
		case 0:
		{
			FCL_CMD = 0x18;

			break;
		}
		case 'l':
		{
			FCL_CMD = 0x18;

			break;
		}
		case 'L':
		{
			FCL_CMD = 0x18;

			break;
		}
		case 1:
		{
			FCL_CMD = 0x1C;

			break;
		}
		case 'r':
		{
			FCL_CMD = 0x1C;

			break;
		}
		case 'R':
		{
			FCL_CMD = 0x1C;

			break;
		}
		// default:

	}

	if (FCL_CMD != -1 & FCL_POSITION != 0)
	{

		while (FCL_POSITION != 0)
		{

			FCD_0c591_lcd_I2C1__RawSend(FCL_CMD, 0);

			FCL_POSITION = FCL_POSITION - 1;


		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Sends data to the LCD display
       :
       :Parameters for macro RawSend:
       :  data : MX_UINT8
       :  mask : MX_UINT8
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__RawSend(MX_UINT8 FCL_DATA, MX_UINT8 FCL_MASK)
{
	//Local variable definitions
	MX_UINT8 FCL_NIBBLE;
	MX_UINT8 FCL_I2DATA;


	//Comment:
	//Clears lower 4 bits and shift upper bits to right x 4

	FCL_I2DATA = (FCL_DATA & 0xF0) >> 4;

	//Comment:
	//Comment

	FCD_0c591_lcd_I2C1__EnablePulse(FCL_I2DATA | FCL_MASK);

	//Comment:
	//Clears upper 4 bits

	FCL_NIBBLE = (FCL_DATA & 0xF0);
	FCL_I2DATA = FCL_DATA ^ FCL_NIBBLE;

	FCD_0c591_lcd_I2C1__EnablePulse(FCL_I2DATA | FCL_MASK);

}

/*=----------------------------------------------------------------------=*\
   Use :Startup routine required by the hardware device.
\*=----------------------------------------------------------------------=*/
void FCD_0c591_lcd_I2C1__Start()
{

	FC_CAL_I2C_Master_Init_1();

	FCI_DELAYBYTE_MS(12);

	FCD_0c591_lcd_I2C1__EnablePulse(3);

	FCI_DELAYBYTE_MS(4);

	FCD_0c591_lcd_I2C1__EnablePulse(3);

	FCD_0c591_lcd_I2C1__EnablePulse(3);

	FCI_DELAYBYTE_MS(4);

	FCD_0c591_lcd_I2C1__EnablePulse(2);

	FCD_0c591_lcd_I2C1__RawSend(0x2C, 0);

	FCD_0c591_lcd_I2C1__RawSend(0x06, 0);

	FCD_0c591_lcd_I2C1__RawSend(0x0C, 0);

	FCD_0c591_lcd_I2C1__RawSend(0x01, 0);

	FCI_DELAYBYTE_MS(2);

}


/*========================================================================*\
   Use :dash_IO_flasher1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :USB_Serial1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data string to the host
       :
       :Parameters for macro SendString:
       :  Data[20] : Data string to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCL_LENGTH;
	MX_UINT8 FCR_RETVAL;


	FCL_LENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		MX_UINT8 n;

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)	//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			return(1);

		// Flowcode strings are not necessarily null terminated
		// so we cannot use  usb_cdc_print_str(FCL_DATA);
		for(n = 0 ; (FCL_DATA[n] != 0)&&(n < FCL_LENGTH); n++)
		{
			usb_cdc_putc(FCL_DATA[n]);
		}

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);	    //USB Not Configured
		}
		else
		{
			CDCTxService();		//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(FCL_DATA, FCL_LENGTH);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific

	        MX_UINT8 n;

	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            for(n = 0; (FCL_DATA[n] != 0) && (n < FCL_LENGTH); n++) {
	                FCL_TIMEOUT = 0;
	                while((!uart_usb_tx_ready()) && (FCL_TIMEOUT < 32000))
	                    FCL_TIMEOUT++;

	                if(FCL_TIMEOUT == 32000) {
	                    return(1);
	                } else {
	                    uart_usb_putchar(FCL_DATA[n]);
	                    Usb_ack_in_ready();
	                }
	            }
	        }

	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives a string from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadString:
       :  Timeout_ms : Length of time to wait before timing out
       :  Length : Maximum number of bytes to try and read
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_056e1_USB_Serial1__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);


	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC			//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER)
		{
			Rx_Length = usb_cdc_rx_avail();		// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > FCL_LENGTH)
					Rx_Length = FCL_LENGTH;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < FCL_LENGTH)
					FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;
			}
		}

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, FCL_LENGTH);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}

	  #endif

	  #ifdef MX_CAL_AVR			//AVR specific

		MX_UINT8 Rx_Length = 0;
		MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER) {
	        if(uart_usb_test_hit()) {
	            FCL_WAIT_FOREVER = 0;
	            while(uart_usb_test_hit() && (Rx_Length <= FCL_LENGTH)) {
	                FCR_RETVAL[Rx_Length++] = uart_usb_getchar();
	            }
	        } else {
				inner++;
				delay_us(10);
				if (inner == 100) {
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
	        }
	    }
		if (Rx_Length < FCL_LENGTH)
		    FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string

	  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data byte to the host
       :
       :Parameters for macro SendByte:
       :  data : Data byte to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__SendByte(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)			//Pipeline full or disconnected
			return(1);

		usb_cdc_putc(FCL_DATA);

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);		//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(&FCL_DATA,1);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific
	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            Usb_select_endpoint(TX_EP);
	            while((uart_usb_tx_ready() == 0) && (FCL_TIMEOUT < 32000))
	                FCL_TIMEOUT++;

	            if(FCL_TIMEOUT == 32000) {
	                return(1);
	            } else {
	                uart_usb_putchar(FCL_DATA);
	                Usb_ack_in_ready();
	            }
	        }
	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives the byte from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadByte:
       :  Timeout_ms : Number of milliseconds to wait before timing out
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_056e1_USB_Serial1__ReadByte(MX_UINT8 FCL_TIMEOUT_MS)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);
	MX_UINT16 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	#else

		FCR_RETVAL = 255;

	#endif

	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
	        else
	            FCR_RETVAL = retval[0];
		}
		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_AVR		//AVRspecific

	    MX_UINT8 rx_rdy = 0;
	    MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while((rx_rdy == 0) && (FCL_TIMEOUT_MS > 0))
		{
			rx_rdy = uart_usb_test_hit();
	        if(rx_rdy)
	            FCR_RETVAL = uart_usb_getchar();

			if ((FCL_WAIT_FOREVER == 0) && (rx_rdy == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}
		return (FCR_RETVAL);
	  #endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Starts up the USB communications and attempts to enumerate.

       :Returns 0 for a successful startup or 255 for a enumeration timeout.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__Initialise()
{
	//Local variable definitions
	MX_UINT16 FCL_DELAY_COUNTER = (0x0);
	MX_UINT8 FCR_RETVAL;


	#ifdef MX_CAL_PIC                                //8-bit PIC specific
	  #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
	  //On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the OSCTUNE&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	      while(pll_startup_counter--);
	  }
	  //Device switches over automatically to PLL output after PLL is locked and ready.
	  #endif
	#endif

	#ifdef MX_CAL_PIC16                        //16-bit PIC specific
	  #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
	  //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the CLKDIV&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      CLKDIVbits.PLLEN = 1;
	      while(pll_startup_counter--);
	  }
	  #endif
	#endif

	#ifdef MX_CAL_AVR                          //ATmega or AT90
	//  #if defined(AT90USB162)
	//  {
	      Usb_enable_regulator();
	//  }
	//  #endif
	#endif

	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific
	    USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
	        USBDeviceAttach();
	  #elif defined MX_CAL_AVR
	      usb_task_init();
	  #endif

	#if (0)

	//Code has been optimised out by the pre-processor
	#else

		#if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific
		  while(USBDeviceState != CONFIGURED_STATE);
		#elif defined MX_CAL_AVR
		  while(Is_device_enumerated() == 0) {
		    usb_task();
		  }
		  uart_usb_init();
		#endif

		FCR_RETVAL = 0;

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON0=0x00;
ADCON1 = 0x0F;
UCFG = 0x08;
cr_bit(PIE2, USBIE);




	// PIC init start
	// Output: 0 -> E0
	FCP_SET(B, E, 0x01, 0, (0));
	// Initialize USB
	// Call Component Macro: USB_Serial1::Initialise()
	FCD_056e1_USB_Serial1__Initialise();

	// Initialize LCD
	// Call Component Macro: lcd_I2C1::Start()
	FCD_0c591_lcd_I2C1__Start();

	// PIC init complete
	// Output: 1 -> E0
	FCP_SET(B, E, 0x01, 0, (1));
	// Loop
	// Loop: While 1
	while (1)
	{

		// Read 1 byte from buff
		// Call Component Macro: Byte_data=USB_Serial1::ReadByte(10)
		FCV_BYTE_DATA = FCD_056e1_USB_Serial1__ReadByte(10);

		// Check if mode is idle
		// Decision: Byte_data == 1 | Byte_data == 2 | Byte_data == 3?
		if (FCV_BYTE_DATA == 1 | FCV_BYTE_DATA == 2 | FCV_BYTE_DATA == 3)
		{

			// Assign new mode
			// Calculation:
			//  mode = Byte_data
			FCV_MODE = FCV_BYTE_DATA;

		// } else {

		}

		// Switch
		// Switch: mode?
		switch (FCV_MODE)
		{
			case 1:
			{
				//Comment:
				//Waiting for input 
				//from host (idle)

				break;
			}
			case 2:
			{
				// Output
				// Output: 1 -> A0
				FCP_SET(B, A, 0x01, 0, (1));
				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(97)
				FCD_056e1_USB_Serial1__SendByte(97);

				break;
			}
			case 3:
			{
				// Output
				// Output: 0 -> A0
				FCP_SET(B, A, 0x01, 0, (0));
				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(97)
				FCD_056e1_USB_Serial1__SendByte(97);

				break;
			}
			// default:

		}

		// ack
		// Call Component Macro: USB_Serial1::SendByte(Byte_data)
		FCD_056e1_USB_Serial1__SendByte(FCV_BYTE_DATA);


	}

	// Call Component Macro
	// Call Component Macro: USB_Serial1::SendString("Hello world")
	FCD_056e1_USB_Serial1__SendString("Hello world", 12);

	// Call Component Macro
	// Call Component Macro: String_data=USB_Serial1::ReadString(100, 64)
	FCD_056e1_USB_Serial1__ReadString(FCV_STRING_DATA,20, 100, 64);

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	

	#ifdef MX_CAL_PIC 
	  USBDeviceTasks(); 
	#endif 
}




