//************************************************************************************
//**  
//**  Source name:   D:\Campus\sem 6\CO326  Computer Systems Engineering Industrial Networks\labs\working\Flowcode1.fcfx
//**  Title:         
//**  Description:   
//**  Device:        PIC.18F.18F4550
//**  
//**  Generated by:  Flowcode v7.1.1.0
//**  Date:          Thursday, January 24, 2019 17:55:13
//**  Users:         1
//**  Registered to: 
//**  Licence key:   _READ_
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_PIC

#define MX_CAL_PIC

#define MX_CLK_SPEED 19660800

#define FCP_NULL Unconnected_Port



#include <xc.h>
#include <math.h>

__PROG_CONFIG(0x1, 0xFEEC);
__PROG_CONFIG(0x2, 0xFEFF);
__PROG_CONFIG(0x3, 0xFFFF);
__PROG_CONFIG(0x4, 0xFF9B);
__PROG_CONFIG(0x5, 0xFFFF);
__PROG_CONFIG(0x6, 0xFFFF);
__PROG_CONFIG(0x7, 0xFFFF);

/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\internals.c"



/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_READ_BYTE = (0x61);
MX_GLOBAL MX_UINT8 FCV_INPUT_SWITCHES;


/*========================================================================*\
   Use :dash_IO_flasher1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :USB_Serial1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define dev_name 18,3,'H',0,'a',0,'r',0,'s',0,'h',0,'a',0,'n',0,'a',0
#define dev_name_count 18
#define dev_name_DS 'H','a','r','s','h','a','n','a'
#define dev_name_count_DS 8
#define MX_USB_TYPE1
#define timeout 10
#define RX_BUF_SZ (64)
#define MX_VID 4799
#define enumeration_tout 0
#define TX_BUF_SZ (64)
#define major_version 1
#define MX_PID 61456
#define dev_manufacturer 46,3,'M',0,'a',0,'t',0,'r',0,'i',0,'x',0,' ',0,'M',0,'u',0,'l',0,'t',0,'i',0,'m',0,'e',0,'d',0,'i',0,'a',0,' ',0,'L',0,'t',0,'d',0,'.',0
#define dev_manufacturer_count 46
#define dev_manufacturer_DS 'M','a','t','r','i','x',' ','M','u','l','t','i','m','e','d','i','a',' ','L','t','d','.'
#define dev_manufacturer_count_DS 22
#define minor_version 0


/*=----------------------------------------------------------------------=*\
   Use :USB_Serial1
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_VERSION ((major_version << 8) | minor_version)

#ifdef MX_CAL_PIC							//8-bit PIC specific

    #ifdef MX_USB_TYPE1                     //ECIO / MIAC / 18F4455
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x500
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x540
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x580
    #endif

    #ifdef MX_USB_TYPE3                     //18F14K50
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x240
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x280
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x2C0
    #endif

    #ifdef MX_USB_TYPE5                     //16F1455
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x0A0
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x120
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x1A0
    #endif

    #ifdef MX_USB_TYPE6                     //18F45K50
        #define FIXED_ADDRESS_MEMORY
        #define IN_DATA_BUFFER_ADDRESS_TAG      @0x500
        #define OUT_DATA_BUFFER_ADDRESS_TAG     @0x540
        #define CONTROL_BUFFER_ADDRESS_TAG      @0x580
    #endif

	#ifdef MX_USB_TYPE0
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"../../../CAL/PIC/USB/usb_serial_config.h"

    #include USB_CONFIG

	// USB library includes
	#include "../../../CAL/PIC/USB/usb.h"
	#include "../../../CAL/PIC/USB/usb_device.h"
	#include "../../../CAL/PIC/USB/usb_device_cdc.h"
	//#include "../../../CAL/PIC/USB/system.h"

    #include "../../../CAL/PIC/USB/usb_device.c"
    #include "../../../CAL/PIC/USB/usb_device_cdc.c"
    #include "../../../CAL/PIC/USB/usb_hal_16bit.c"
	//#include "../../../CAL/PIC/USB/system.c"
	
	// Device name and manufacturer
    const struct{uint8_t bLength;uint8_t bDscType;uint16_t string[dev_manufacturer_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};
    const struct{uint8_t bLength;uint8_t bDscType;uint16_t string[dev_name_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_name_DS}};

    #include "../../../CAL/PIC/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC/USB/usb_serial_handler.c"

#endif

#ifdef MX_CAL_PIC16					//16-bit PIC specific

	#ifndef MX_USB_TYPE1
		#error "Your target device does not support USB components"
	#endif

	// Global Defines
	#define USB_BUS_SENSE       1
	#define self_power          1
	#define tris_usb_bus_sense	1
	#define tris_self_power		1

	#define USB_CONFIG	"usb_serial_config.h"

	// USB library includes
	#include "../../../CAL/PIC16BIT/USB/usb_serial_config.h"
	#include "../../../CAL/PIC16BIT/USB/usb.h"
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.h"
	#include "../../../CAL/PIC16BIT/USB/GenericTypeDefs.h"
	#include "../../../CAL/PIC16BIT/USB/Compiler.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.h"
	#include "../../../CAL/PIC16BIT/USB/usb_device.c"
	#include "../../../CAL/PIC16BIT/USB/usb_ch9.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.c"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.c"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.c"
    #endif
	#include "../../../CAL/PIC16BIT/USB/usb_function_cdc.c"
	#include "../../../CAL/PIC16BIT/USB/usb_common.h"
	#include "../../../CAL/PIC16BIT/USB/usb_hal.h"
    #if defined(__dsPIC33E__) 
      #include "../../../CAL/PIC16BIT/USB/usb_hal_dspic33e.h"
    #elif defined(__PIC24E__)
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24e.h"
    #else
      #include "../../../CAL/PIC16BIT/USB/usb_hal_pic24.h"
    #endif
	
	// Device name and manufacturer
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_name_count_DS];}sd001={sizeof(sd001),USB_DESCRIPTOR_STRING,{dev_name_DS}};
	ROM struct{BYTE bLength;BYTE bDscType;WORD string[dev_manufacturer_count_DS];}sd002={sizeof(sd002),USB_DESCRIPTOR_STRING,{dev_manufacturer_DS}};

	#include "../../../CAL/PIC16BIT/USB/usb_serial_descriptors.c"
    #include "../../../CAL/PIC16BIT/USB/usb_cdc_handler.c"

#endif


#ifdef MX_CAL_AVR					//AVR specific

#include "config.h"
#include "lib_mcu/usb/usb_drv.h"
#include "modules\usb\device_chap9\usb_standard_request.h"
#include "usb_specific_request.h"
#include "uart_usb_lib.h"

extern U8    rx_counter;
extern U8    tx_counter;

S_line_coding line_coding;
S_line_status line_status;      // for detection of serial state input lines
S_serial_state serial_state;    // for serial state output lines

#endif

MX_UINT8 FCD_056e1_USB_Serial1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA);
void FCD_056e1_USB_Serial1__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH);
MX_UINT8 FCD_056e1_USB_Serial1__SendByte(MX_UINT8 FCL_DATA);
MX_UINT16 FCD_056e1_USB_Serial1__ReadByte(MX_UINT8 FCL_TIMEOUT_MS);
MX_UINT8 FCD_056e1_USB_Serial1__Initialise();

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 7\CAL\includes.c"


/*========================================================================*\
   Use :dash_IO_flasher1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :COMPort
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :USB_Serial1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data string to the host
       :
       :Parameters for macro SendString:
       :  Data[20] : Data string to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__SendString(MX_CHAR *FCL_DATA, MX_UINT16 FCLsz_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCL_LENGTH;
	MX_UINT8 FCR_RETVAL;


	FCL_LENGTH = FCI_GETLENGTH(FCL_DATA, FCLsz_DATA);

	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		MX_UINT8 n;

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)	//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			return(1);

		// Flowcode strings are not necessarily null terminated
		// so we cannot use  usb_cdc_print_str(FCL_DATA);
		for(n = 0 ; (FCL_DATA[n] != 0)&&(n < FCL_LENGTH); n++)
		{
			usb_cdc_putc(FCL_DATA[n]);
		}

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
		{
			return(2);	    //USB Not Configured
		}
		else
		{
			CDCTxService();		//Required or every other send fails

			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(FCL_DATA, FCL_LENGTH);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific

	        MX_UINT8 n;

	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            for(n = 0; (FCL_DATA[n] != 0) && (n < FCL_LENGTH); n++) {
	                FCL_TIMEOUT = 0;
	                while((!uart_usb_tx_ready()) && (FCL_TIMEOUT < 32000))
	                    FCL_TIMEOUT++;

	                if(FCL_TIMEOUT == 32000) {
	                    return(1);
	                } else {
	                    uart_usb_putchar(FCL_DATA[n]);
	                    Usb_ack_in_ready();
	                }
	            }
	        }

	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives a string from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadString:
       :  Timeout_ms : Length of time to wait before timing out
       :  Length : Maximum number of bytes to try and read
       :
       :Returns : MX_CHAR*
\*=----------------------------------------------------------------------=*/
void FCD_056e1_USB_Serial1__ReadString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL, MX_UINT8 FCL_TIMEOUT_MS, MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);


	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC			//8-bit PIC specific

		MX_UINT8 Rx_Length;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER)
		{
			Rx_Length = usb_cdc_rx_avail();		// get length of incoming data string
			if (Rx_Length)
			{
				if (Rx_Length > FCL_LENGTH)
					Rx_Length = FCL_LENGTH;

				usb_ep_get_rx_buffer(Rx_Length, FCR_RETVAL);	// copy data string to local buffer

				if (Rx_Length < FCL_LENGTH)
					FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string
				return;
			}
			else
			{
				Wdt_Delay_Ms(1);
				FCL_TIMEOUT_MS = FCL_TIMEOUT_MS - 1;
			}
		}

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(FCR_RETVAL, FCL_LENGTH);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}

	  #endif

	  #ifdef MX_CAL_AVR			//AVR specific

		MX_UINT8 Rx_Length = 0;
		MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while (FCL_TIMEOUT_MS || FCL_WAIT_FOREVER) {
	        if(uart_usb_test_hit()) {
	            FCL_WAIT_FOREVER = 0;
	            while(uart_usb_test_hit() && (Rx_Length <= FCL_LENGTH)) {
	                FCR_RETVAL[Rx_Length++] = uart_usb_getchar();
	            }
	        } else {
				inner++;
				delay_us(10);
				if (inner == 100) {
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
	        }
	    }
		if (Rx_Length < FCL_LENGTH)
		    FCR_RETVAL[Rx_Length] = 0;		//Add null MX_UINT8acter to end of string

	  #endif

}

/*=----------------------------------------------------------------------=*\
   Use :Sends the specified data byte to the host
       :
       :Parameters for macro SendByte:
       :  data : Data byte to send to the host
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__SendByte(MX_UINT8 FCL_DATA)
{
	//Local variable definitions
	MX_UINT16 FCL_TIMEOUT = (0x0);
	MX_UINT8 FCR_RETVAL;


	#if 0 // Disabled code
	  #ifdef MX_CAL_PIC		//8-bit PIC specific

		while (usb_cdc_tx_empty() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
			FCL_TIMEOUT = FCL_TIMEOUT + 1;

		if (FCL_TIMEOUT == 32000)			//Pipeline full or disconnected
			return(1);

		usb_cdc_putc(FCL_DATA);

	  #endif

	#endif // #if 0: Disabled code
	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

	  	if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1))
	  	{
	  		return(2);		//USB Not Configured
	  	}
	  	else
	  	{
			CDCTxService();													//Required or every other send fails
			while (mUSBUSARTIsTxTrfReady() == 0 && FCL_TIMEOUT < 32000)		//Wait for outgoing buffer to empty
				FCL_TIMEOUT = FCL_TIMEOUT + 1;

			if (FCL_TIMEOUT == 32000)	//Pipeline full or disconnected
			{
				return(1);		//USB Not Ready
			}
			else
			{
				putUSBUSART(&FCL_DATA,1);
			}
		}
		CDCTxService();

	  #endif

	#ifdef MX_CAL_AVR          //AVR specific
	        if(!Is_device_enumerated()) {
	            return(2);
	        } else {
	            Usb_select_endpoint(TX_EP);
	            while((uart_usb_tx_ready() == 0) && (FCL_TIMEOUT < 32000))
	                FCL_TIMEOUT++;

	            if(FCL_TIMEOUT == 32000) {
	                return(1);
	            } else {
	                uart_usb_putchar(FCL_DATA);
	                Usb_ack_in_ready();
	            }
	        }
	#endif


	FCR_RETVAL = 0;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Retreives the byte from the incoming data buffer. If data is available then the macro will return straight away. If there is no data available then the macro waits up the the period specified by the timeout before returning the value 255.
       :
       :Parameters for macro ReadByte:
       :  Timeout_ms : Number of milliseconds to wait before timing out
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_056e1_USB_Serial1__ReadByte(MX_UINT8 FCL_TIMEOUT_MS)
{
	//Local variable definitions
	MX_UINT8 FCL_WAIT_FOREVER = (0x0);
	MX_UINT16 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	#else

		FCR_RETVAL = 255;

	#endif

	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific

		MX_UINT8 retval[1];
		MX_UINT8 inner = 0;
		MX_UINT16 numBytesRead = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while(numBytesRead == 0 && FCL_TIMEOUT_MS > 0)
		{
			numBytesRead = getsUSBUSART(retval,1);
			if ((FCL_WAIT_FOREVER == 0) && (numBytesRead == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
	        else
	            FCR_RETVAL = retval[0];
		}
		return (FCR_RETVAL);

	  #endif

	  #ifdef MX_CAL_AVR		//AVRspecific

	    MX_UINT8 rx_rdy = 0;
	    MX_UINT8 inner = 0;

		if(FCL_TIMEOUT_MS == 255)
			FCL_WAIT_FOREVER = 1;

		while((rx_rdy == 0) && (FCL_TIMEOUT_MS > 0))
		{
			rx_rdy = uart_usb_test_hit();
	        if(rx_rdy)
	            FCR_RETVAL = uart_usb_getchar();

			if ((FCL_WAIT_FOREVER == 0) && (rx_rdy == 0))
			{
				inner++;
				delay_us(10);
				if (inner == 100)
				{
					inner = 0;
					FCL_TIMEOUT_MS--;
				}
			}
		}
		return (FCR_RETVAL);
	  #endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Starts up the USB communications and attempts to enumerate.
       :Returns 0 for a successful startup or 255 for a enumeration timeout.
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_056e1_USB_Serial1__Initialise()
{
	//Local variable definitions
	MX_UINT16 FCL_DELAY_COUNTER = (0x0);
	MX_UINT8 FCR_RETVAL;


	#ifdef MX_CAL_PIC                                //8-bit PIC specific
	  #if defined(P18F24J50) || defined(P18F25J55) || defined(P18F26J50) || defined(P18F44J50) || defined(P18F45J50) || defined(P18F46J55) || defined(P18F87J50) ||  defined(P18F86J55) || defined(P18F86J50) || defined(P18F85J50) || defined(P18F67J50) || defined(P18F66J55) || defined(P18F66J50) || defined(P18F65J50)
	  //On the PIC18F87J50 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the OSCTUNE&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      OSCTUNEbits.PLLEN = 1;  //Enable the PLL and wait 2+ms until the PLL locks before enabling USB module
	      while(pll_startup_counter--);
	  }
	  //Device switches over automatically to PLL output after PLL is locked and ready.
	  #endif
	#endif

	#ifdef MX_CAL_PIC16                        //16-bit PIC specific
	  #if defined(P24FJ64GB004) || defined(P24FJ64GB002) || defined(P24FJ32GB004) || defined(P24FJ32GB002)
	  //On the PIC24FJ64GB004 Family of USB microcontrollers, the PLL will not power up and be enabled
	  //by default, even if a PLL enabled oscillator configuration is selected (such as HS+PLL).
	  //This allows the device to power up at a lower initial operating frequency, which can be
	  //advantageous when powered from a source which is not gauranteed to be adequate for 48MHz
	  //operation.  On these devices, user firmware needs to manually set the CLKDIV&lt;PLLEN&gt; bit to
	  //power up the PLL.
	  {
	      MX_UINT16 pll_startup_counter = 600;
	      CLKDIVbits.PLLEN = 1;
	      while(pll_startup_counter--);
	  }
	  #endif
	#endif

	#ifdef MX_CAL_AVR                          //ATmega or AT90
	//  #if defined(AT90USB162)
	//  {
	      Usb_enable_regulator();
	//  }
	//  #endif
	#endif

	  #if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific
	    USBDeviceInit();
		if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
	        USBDeviceAttach();
	  #elif defined MX_CAL_AVR
	      usb_task_init();
	  #endif

	#if (0)

	//Code has been optimised out by the pre-processor
	#else

		#if defined(MX_CAL_PIC) || defined(MX_CAL_PIC16)		//8-bit/16-bit PIC specific
		  while(USBDeviceState != CONFIGURED_STATE);
		#elif defined MX_CAL_AVR
		  while(Is_device_enumerated() == 0) {
		    usb_task();
		  }
		  uart_usb_init();
		#endif

		FCR_RETVAL = 0;

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
void main()
{
ADCON0=0x00;
ADCON1 = 0x0F;
UCFG = 0x08;
cr_bit(PIE2, USBIE);




	// Output
	// Output: 0xff -> PORTD
	FCP_SET(F, D, 0xFF, 0, (0xff));
	// Output
	// Output: 1 -> A1
	FCP_SET(B, A, 0x02, 1, (1));
	// Call Component Macro
	// Call Component Macro: USB_Serial1::Initialise()
	FCD_056e1_USB_Serial1__Initialise();

	// Delay
	// Delay: 100 ms
	FCI_DELAYBYTE_MS(100);

	// Output
	// Output: 1 -> A0
	FCP_SET(B, A, 0x01, 0, (1));
	// Output
	// Output: 0 -> PORTD
	FCP_SET(F, D, 0xFF, 0, (0));
	// Delay
	// Delay: 1000 ms
	FCI_DELAYINT_MS(1000);

	// Call Component Macro
	// Call Component Macro: USB_Serial1::SendString("HELLO WORLD")
	FCD_056e1_USB_Serial1__SendString("HELLO WORLD", 12);

	// Loop
	// Loop: While 1
	while (1)
	{

		// Input
		// Input: PORTB -> input_switches
		FCV_INPUT_SWITCHES = FCP_GET(F, B, 0xFF, 0);
		// Call Component Macro
		// Call Component Macro: read_byte=USB_Serial1::ReadByte(255)
		FCV_READ_BYTE = FCD_056e1_USB_Serial1__ReadByte(255);

		// check start sequence
		// Decision: (read_byte >> 4) = 0b0101?
		if ((FCV_READ_BYTE >> 4) == 5)
		{

			// Output
			// Output: 1 -> A2
			FCP_SET(B, A, 0x04, 2, (1));
			// check opcode
			// Decision: (read_byte & 1) == 0?
			if ((FCV_READ_BYTE & 1) == 0)
			{

				//Comment:
				//Read
				//command - P

				// Output
				// Output: 0 -> A3
				FCP_SET(B, A, 0x08, 3, (0));
				// Output
				// Output: 1 -> A4
				FCP_SET(B, A, 0x10, 4, (1));
				// read address
				// Call Component Macro: read_byte=USB_Serial1::ReadByte(255)
				FCV_READ_BYTE = FCD_056e1_USB_Serial1__ReadByte(255);

				// check address
				// Decision: (read_byte & 1) == 0?
				if ((FCV_READ_BYTE & 1) == 0)
				{

					//Comment:
					//command - L

					// Output
					// Output: 0b00000110 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (6));
				} else {

					//Comment:
					//command - M

					// Output
					// Output: 0b00001001 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (9));
				}

				// Input
				// Input: PORTD -> read_byte
				FCV_READ_BYTE = FCP_GET(F, D, 0xFF, 0);
				//Comment:
				//sending ack

				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(0b00100011)
				FCD_056e1_USB_Serial1__SendByte(35);

				// Delay
				// Delay: 10 ms
				FCI_DELAYBYTE_MS(10);

				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(read_byte)
				FCD_056e1_USB_Serial1__SendByte(FCV_READ_BYTE);

			} else {

				//Comment:
				//Write
				//command - Q

				// Output
				// Output: 1 -> A3
				FCP_SET(B, A, 0x08, 3, (1));
				// Output
				// Output: 0 -> A4
				FCP_SET(B, A, 0x10, 4, (0));
				// ready to write
				// Output: 0b00000101 -> PORTB
				FCP_SET(F, B, 0xFF, 0, (5));
				// read address
				// Call Component Macro: read_byte=USB_Serial1::ReadByte(255)
				FCV_READ_BYTE = FCD_056e1_USB_Serial1__ReadByte(255);

				// check address
				// Decision: (read_byte & 3) == 2?
				if ((FCV_READ_BYTE & 3) == 2)
				{

					//Comment:
					//command - N

					// Call Component Macro
					// Call Component Macro: read_byte=USB_Serial1::ReadByte(255)
					FCV_READ_BYTE = FCD_056e1_USB_Serial1__ReadByte(255);

					// Output
					// Output: read_byte -> PORTD
					FCP_SET(F, D, 0xFF, 0, (FCV_READ_BYTE));
					//Comment:
					//sending a signal to indicate write command

					// write high
					// Output: 0b00010101 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (21));
					// Delay
					// Delay: 1 ms
					FCI_DELAYBYTE_MS(1);

					// write low
					// Output: 0b00000101 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (5));
				} else {

					//Comment:
					//command - O

					// Call Component Macro
					// Call Component Macro: read_byte=USB_Serial1::ReadByte(255)
					FCV_READ_BYTE = FCD_056e1_USB_Serial1__ReadByte(255);

					// Output
					// Output: read_byte -> PORTD
					FCP_SET(F, D, 0xFF, 0, (FCV_READ_BYTE));
					//Comment:
					//sending a signal to indicate write command

					// write high
					// Output: 0b01000101 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (69));
					// Delay
					// Delay: 1 ms
					FCI_DELAYBYTE_MS(1);

					// write low
					// Output: 0b00000101 -> PORTB
					FCP_SET(F, B, 0xFF, 0, (5));
				}

				//Comment:
				//sending ack

				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(0b00100100)
				FCD_056e1_USB_Serial1__SendByte(36);

				// Delay
				// Delay: 10 ms
				FCI_DELAYBYTE_MS(10);

				// Call Component Macro
				// Call Component Macro: USB_Serial1::SendByte(read_byte)
				FCD_056e1_USB_Serial1__SendByte(FCV_READ_BYTE);

			}

		// } else {

		}


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/
void MX_INTERRUPT_MACRO(void)
{

	

	#ifdef MX_CAL_PIC 
	  USBDeviceTasks(); 
	#endif 
}




